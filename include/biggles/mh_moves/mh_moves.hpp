/// @file mh_moves.hpp Metropolis-Hastings proposal moves

/// @page mh_moves The Metropolis-Hastings Proposal Moves
///
/// Biggles uses the Metropolis-Hastings algorithm to draw samples of track configurations from the conditional
/// distribution \f$ P(T | \theta, D)\f$. As part of the Metropolis-Hastings algorithm there must be some proposal
/// distribution, \f$ Q(T'|T) \f$, which can propose a new track configuration, \f$ T' \f$, from an existing
/// configuration, \f$ T \f$.
///
/// These update moves form the core of Biggles' optimisation strategy. Any tracks which are generated must, by
/// definition of the Metropolis-Hastings algorithm, have been reached by a chain of proposals as generated by the
/// functions in the biggles::mh_moves namespace.
///
/// The efficiency of the algorithm, in terms of iteration count, depends on these proposals being daring enough to
/// explore the configuration space well, small enough to allow for a high enough acceptance rate and generic enough to
/// make sure all track configurations could be considered eventually.
///
/// Given an existing track configuration, or <em>partition</em>, the proposal distribution will select uniformly a move
/// type to perform. The possible move types are \em birth, \em death, \em extend, \em reduce, \em split, \em merge and
/// \em update.
///
/// Once the move type is selected a move proposal will be generated. This generation might \em fail. If a move fails
/// The old sample will be kept.
///
/// \section birth_move Birth move
///
/// See mh_moves/birth.cpp for up-to-date documentation
///
/// The birth move will create a new track by promoting observations currently in the clutter. To do this, it selects an
/// observation at random and attempts to 'grow' a new track forward in time. To grow a new track Biggles makes use of a
/// few 'laws of physics' to reduce the possible space of new tracks. It is assumed that there is a maximum span of time
/// beyond which a molecule must generate an observation or the track will not be considered. Similarly, there is a
/// 'speed of light' which is the maximum distance in pixels that a molecule may move in one time step. These values are
/// merely present to reduce the search space and should generally be set to very inclusive values. When sampling an
/// observation to add to a track, only those observations within the 'light-cone' of the last observation added to the
/// track are considered and, of those observations, only those within the maximum time interval.
///
/// Once the candidate set of observations has been constructed, a time stamp is selected uniformly from the range
/// covered and an observation is sampled uniformly from those at that time stamp. The sampling is performed in this
/// manner to make sure that the track lengths generated by this sampling method are not influenced by the number of
/// observations in the light cone in any one frame.
///
/// The track is extended in this manner until sampling an observation fails. The reverse step for a birth move is a
/// death move.
///
/// \section death_move Death move
///
/// The death move removes a track from the partition be demoting all observations within it to the clutter. From all
/// tracks, one is selected uniformly and is deleted. The reverse move for a death move is a birth move.
///
/// \section extend_move Extend move
///
/// The extend move is similar to the birth move except that an existing track is extended using the sampling process
/// outlined above. In addition, this sampling may be performed forward or backward in time. The direction is sampled
/// uniformly. The reverse move for an extend move is the reduce move.
///
/// \section reduce_move Reduce move
///
/// The reduce move shortens an existing track. A track is sampled uniformly and within it an observation is sampled.
/// That observation and all following (or, for a backward move, all preceding) observations are demoted to the clutter.
/// The reverse move for a reduce move is the extend move.
///
/// \section split_move Split move
///
/// <b>FIXME:</b> To be documented.
///
/// \section merge_move Merge move
///
/// <b>FIXME:</b> To be documented.
///
/// \section update_move Update move
///
/// <b>FIXME:</b> To be documented.

#ifndef BIGGLES_MH_MOVES_HPP___
#define BIGGLES_MH_MOVES_HPP___

#include <vector>

#include "../object.hpp"
#include "../partition.hpp"
#include "../sampling/simple.hpp"
#include "../detail/fun.hpp"
#include "utility.hpp"
#include "../tools/debug.hpp"

namespace biggles
{

/// @brief Proposal moves for the Metropolis-Hastings partition sampler
namespace mh_moves
{

/// \brief converts a track into a string
std::string track_to_str(const track & track0, time_stamp end_ts = 0);


/// @brief The type of proposal moves which are possible.
enum move_type {
    NONE,
    BIRTH,
    DEATH,
    // TAXES,
    EXTEND,
    REDUCE,
    SPLIT,
    MERGE,
    UPDATE,
    TRANSFER,
    CROSS_OVER,
    FLIP,
    IDENTITY,
    MOVE_COUNT,
};

inline std::string move_name(const mh_moves::move_type &type) {
    std::vector<std::string> move_names(mh_moves::MOVE_COUNT);
    move_names[mh_moves::NONE] = "None";
    move_names[mh_moves::BIRTH] = "Birth";
    move_names[mh_moves::DEATH] = "Death";
    move_names[mh_moves::EXTEND] = "Extend";
    move_names[mh_moves::REDUCE] = "Reduce";
    move_names[mh_moves::SPLIT] = "Split";
    move_names[mh_moves::MERGE] = "Merge";
    move_names[mh_moves::UPDATE] = "Update";
    move_names[mh_moves::TRANSFER] = "Transfer";
    move_names[mh_moves::CROSS_OVER] = "Cross-over";
    move_names[mh_moves::FLIP] = "Flip";
    move_names[mh_moves::IDENTITY] = "Identity";
    return move_names[size_t(type)];
}

inline std::string move_sign(const mh_moves::move_type &type) {
    std::vector<std::string> move_names(mh_moves::MOVE_COUNT);
    move_names[mh_moves::NONE] = "Non";
    move_names[mh_moves::BIRTH] = "Bir";
    move_names[mh_moves::DEATH] = "Dth";
    move_names[mh_moves::EXTEND] = "Ext";
    move_names[mh_moves::REDUCE] = "Red";
    move_names[mh_moves::SPLIT] = "Spl";
    move_names[mh_moves::MERGE] = "Mrg";
    move_names[mh_moves::UPDATE] = "Upd";
    move_names[mh_moves::TRANSFER] = "Trf";
    move_names[mh_moves::CROSS_OVER] = "Crs";
    move_names[mh_moves::FLIP] = "Flp";
    move_names[mh_moves::IDENTITY] = "Idy";
    return move_names[size_t(type)];
}

typedef bool (*move_fun) (const partition_ptr_t&, partition_ptr_t&, float&);

move_fun get_move(move_type type);

/// \brief a weighted move sampler
class weighted_move_sampler {
    std::deque<move_type> data_;
    std::deque<float> weights_;
public:
    /// \brief add a move and its weight to the pool
    weighted_move_sampler& add(const move_type &type, const float weight = 1.f) {
        data_.push_back(type);
        weights_.push_back(weight);
        return *this;
    }
    /// \brief sample a move from the pool
    biggles::mh_moves::move_type operator()() const {
        return biggles::sampling::weighted_choice(data_.begin(), weights_.begin(), weights_.end());
    }
};

/// \brief Given a partition select a move type using a weighted sampler
///
/// Information from the partition is used to propose a move type
///
mh_moves::move_type select_move_type(const partition& part);


/// @brief Perform a proposal move.
///
/// @param move The type of move to make.
/// @param start_partition The partition to start from.
/// @param[out] end_partition Updated with the new partition after the birth move if move succeeded.
/// @param[out] proposal_mass_ratio Updated with the logarithm of the ratio of backward move PDF to forward move
/// PDF.
///
/// @return \c true iff the move succeeded.
bool propose(move_type move, const partition_ptr_t& start_partition, partition_ptr_t& end_partition, float& proposal_mass_ratio);

/// @brief Perform a birth move.
///
/// The new track has a dynamic drag of 1.
/// @note It is OK for \p start_partition and \p end_partition to point at the same object.
///
/// @param start_partition The partition to start from.
/// @param[out] end_partition Updated with the new partition after the birth move if move succeeded.
/// @param[out] proposal_mass_ratio Updated with the logarithm of the ratio of backward move PDF to forward move
/// PDF.
///
/// @return \c true iff the birth move succeeded.
bool birth(const partition_ptr_t& start_partition, partition_ptr_t& end_partition, float& proposal_mass_ratio);

/// @brief Perform a death move.
///
/// @note It is OK for \p start_partition and \p end_partition to point at the same object.
///
/// @param start_partition The partition to start from.
/// @param[out] end_partition Updated with the new partition after the death move if move succeeded.
/// @param[out] proposal_mass_ratio Updated with the logarithm of the ratio of backward move PDF to forward move
/// PDF.
///
/// @return \c true iff the death move succeeded.
bool death(const partition_ptr_t& start_partition, partition_ptr_t& end_partition, float& proposal_mass_ratio);

/// @brief Perform an split move.
///
/// The new tracks have a dynamic drag equal to that of the original track.
/// @note It is OK for \p start_partition and \p end_partition to point at the same object.
///
/// @param start_partition The partition to start from.
/// @param[out] end_partition Updated with the new partition after the split move if move succeeded.
/// @param[out] proposal_mass_ratio Updated with the logarithm of the ratio of backward move PDF to forward move
/// PDF.
///
/// @return \c true iff the split move succeeded.
bool split(const partition_ptr_t& start_partition, partition_ptr_t& end_partition, float& proposal_mass_ratio);

/// @brief Perform an merge move.
///
/// The new track has a dynamic drag of 1.
/// @note It is OK for \p start_partition and \p end_partition to point at the same object.
///
/// @param start_partition The partition to start from.
/// @param[out] end_partition Updated with the new partition after the merge move if move succeeded.
/// @param[out] proposal_mass_ratio Updated with the logarithm of the ratio of backward move PDF to forward move
/// PDF.
///
/// @return \c true iff the merge move succeeded.
bool merge(const partition_ptr_t& start_partition, partition_ptr_t& end_partition, float& proposal_mass_ratio);

/// @brief Perform an extend move.
///
/// The new track has a dynamic drag equal to the extended track.
/// @note It is OK for \p start_partition and \p end_partition to point at the same object.
///
/// @param start_partition The partition to start from.
/// @param[out] end_partition Updated with the new partition after the extend move if move succeeded.
/// @param[out] proposal_mass_ratio Updated with the logarithm of the ratio of backward move PDF to forward move
/// PDF.
///
/// @return \c true iff the extend move succeeded.
bool extend(const partition_ptr_t& start_partition, partition_ptr_t& end_partition, float& proposal_mass_ratio);

/// @brief Perform an reduce move.
///
/// @note It is OK for \p start_partition and \p end_partition to point at the same object.
///
/// @param start_partition The partition to start from.
/// @param[out] end_partition Updated with the new partition after the reduce move if move succeeded.
/// @param[out] proposal_mass_ratio Updated with the logarithm of the ratio of backward move PDF to forward move
/// PDF.
///
/// @return \c true iff the reduce move succeeded.
bool reduce(const partition_ptr_t& start_partition, partition_ptr_t& end_partition, float& proposal_mass_ratio);

/// @brief Perform an update move.
///
/// There is no proposal density ratio since the update move is symmetric and so the log proposal density ratio is 0.
///
/// If the track was changed, its new dynamic drag of 1.
///
/// @note It is OK for \p start_partition and \p end_partition to point at the same object.
///
/// @param start_partition The partition to start from.
/// @param[out] end_partition Updated with the new partition after the reduce move if move succeeded.
/// PDF.
///
/// @return \c true iff the reduce move succeeded.
bool update(const partition_ptr_t& start_partition, partition_ptr_t& end_partition, float& proposal_mass_ratio);

/// \brief transfers a single observation from one track to another track
bool transfer(const partition_ptr_t& start_partition, partition_ptr_t& end_partition, float& proposal_mass_ratio);

/// \brief a crossover move that exchanges branches of two tracks
///
/// this doesn't change the number of tracks. two tracks are split and merged again
/// so that each of the two new tracks contains a part of both old tracks
bool cross_over(const partition_ptr_t& start_partition, partition_ptr_t& end_partition, float& proposal_mass_ratio);

bool flip(const partition_ptr_t& start_partition, partition_ptr_t& end_partition, float& proposal_mass_ratio);

/// \brief move class wrapping the function
class move_t {
    move_fun _move; ///< \brief the actual function to be called
    move_type _type;
public:
    struct result_t {
        partition_ptr_t proposed_partition;
        bool success;
        float pmr;
    };
    move_t() : _move(0), _type(NONE) {}
    move_t(move_type type) : _move(get_move(type)), _type(type) {}
    bool operator()(const partition_ptr_t& start_part_ptr,
        partition_ptr_t& end_part_ptr, float& proposal_mass_ratio) const
    {
        return _move(start_part_ptr, end_part_ptr, proposal_mass_ratio);
    }
    result_t exec(const partition& start_partition) const {
        if (_type == NONE)
            throw std::runtime_error("move type not defined");
        partition_ptr_t start_part_ptr(new partition(start_partition));
        if (not start_part_ptr->get_capability_recorder()) {
            capability_recorder_ptr cap_rec_ptr = new_cap_recorder(*start_part_ptr);
            start_part_ptr->set_capability_recorder(cap_rec_ptr);
        }
        result_t proposal;
        proposal.success = _move(start_part_ptr, proposal.proposed_partition, proposal.pmr);
        return proposal;
    }
    void set_type(move_type type) {
        _move = get_move(type);
        _type = type;
    }
    move_type type() const { return _type; }
    std::string repr() const { return std::string("biggles.") + move_name(_type) + "Move"; }
    std::string str() const { return move_name(_type); }
};




} // namespace biggles::mh_moves

} // namespace biggles

#endif // BIGGLES_MH_MOVES_HPP___
